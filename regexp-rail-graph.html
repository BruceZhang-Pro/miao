<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>regexp rail graph</title>
  <style>
    /*body {*/
    /*  width: 100%;*/
    /*  height: 100%;*/
    /*}*/
  </style>
</head>
<body>
<!--<svg viewBox="0 0 500 500" id="rail-graph" xmlns="http://www.w3.org/2000/svg">-->
<svg width="2000" height="1000" id="rail-graph" xmlns="http://www.w3.org/2000/svg">
<style>
  rect[class=Escape] {
    fill: #bada55;
  }
  rect[class=Character] {
    fill: #dae8e5;
  }
  rect[class=Special] {
    fill: #6b6659;
    rx: 0;
  }
</style>
</svg>
<script>
  "use strict"
  
  let elementPadding = 10
  let radiiEllipse = elementPadding // 画椭圆时的 x 和 y 的半径, 这里设置为一样的 1倍的padding为正常的椭圆曲线 3倍的padding为机甲风曲线
  let railGraph = document.querySelector("#rail-graph") // svg 对象
  
  // 普通字符转义后的显示
  const ESCAPE = {
    b: "word boundary", //单词边界
    B: "non-word boundary", //匹配非单词边界
    d: "digit", //匹配一个数字
    D: "non-digit", //匹配一个非数字
    f: "form feed (0x0C)", //匹配一个换页符
    n: "line feed (0x0A)", //匹配一个换行符
    r: "carriage return (0x0D)", //匹配一个换行符
    s: "white space", //匹配任何空白字符，包括空格、制表符、换页符
    S: "non-white space", //匹配非空白字符，包括空格、制表符、换页符
    t: "tab (0x09)", //匹配制表符
    v: "vertical tab (0x0B)", //匹配一个垂直制表符
    w: "word", //匹配包括下划线的任何单词字符
    W: "non-word", //匹配任何非单词字符
  }
  
  // 通用字符组
  const GENERAL_CHAR_GROUP = {
    d: true,
    D: true,
    w: true,
    W: true,
    s: true,
    S: true,
  }
  
  const SPECIAL = {
    "^": "Start of line",
    "$": "End of line",
  }

  const COMMON_CHAR = "Character" // 普通字符
  const ESCAPE_CHAR = "Escape" // 转义字符
  const SPECIAL_CHAR = "Special" // 特殊字符 如 ^ $
  
  //待改
  // /asd{,3}/  // 把{,3} 全当做普通字符 ✓
  // /asd{,}/  // 把{,} 全当做普通字符 ✓
  // [abz049_-]  //把 - 在开头和结尾时,当做普通字符  其余的时候当做 前后字母的过度字符 ✓
  // {3}  //量词匹配只能是3次,不能多不能少 ✓
  // 转移字符 在[]里的转义字符 也有问题  ✓
  // ^  $  这两个要画一下 ✓
  // 转义字符显示 ✓
  // 中括号里的转意字符 ✓
  // 中括号里的 中划线连接的字符 ✓
  // 中括号里,中划线连接的转义字符 ✓
  // 普通字符连接在一起 ✓
  // 中括号里的重复项去掉 ✓
  // {3} 量词匹配只能是3次,不能多不能少 ,在画的时候,量词的提示要和 {0,3} 不一样
  // 量词的箭头
  // 量词的文本
  // 量词的提示词
  // 捕获的文本
  // characterClass 的文本
  
  
  //暂时不做的
  // {1,  } 带空格 的问题
  // 转义字符可以转多个字符
  
  // /foo|qwe(as[^2564]|rt{2,})+/
  // /(?<abc>af)foo|(bar|(ba+z{2,})[aeiou])/
  
  // let regexp = /a[yas]+/
  // drawBranchGraph(parseRegularExpression(regexp).branches[0])
  
  // let regexp = /[cb]|a/
  // let regexp = /as*d|(s[wv])+|rt/
  // drawBranchesGraph(parseRegularExpression(regexp).branches)
  // let regexp = /(s)/
  // drawCaptureGraph(parseRegularExpression(regexp).branches[0].character[0])
  
  // let regexp = /as*d|(s[wv])+|rt/
  // let regexp = /\[[-+]?([048]|\d*(?:[02468][048]|[13579][26]))\]/ // 我测试的
  // let regexp = /a\b[a-za-zA^\^]\n\^^\$$/ // 测试转义字符
  // let regexp = /^a${s\da\^^234}[12ad3456]/ // 测试去重
  
  // let regexp = /(foo+|aaaa)*b(a[abz049_-]){2,}?(baz|baa)+|baaa/  // 大喵的
  // let regexp = /a\b\n\^^\$$/
  // let regexp = /a\b^[\da^\^^]\n\^\$$/ // 测试转义字符
  let regexp = /(zhang(ziC[a-z]heng)+fo)*?(?=fa)(?:fa)|ba([^fa\rffaou]{1,2}?f)alf(b*?a+z{2,5})[aeio\b]|[^fa\n\t][\n-z1-9][a-z]/
  // let regexp = /s{2,5}34/
  // let regexp = /a\d[\n-\f]g[\nd\d]r\B|[\W-a]/ // 测试转义字符
  console.log(parseRegularExpression(regexp))
  
  drawRegularExpressionGraph(parseRegularExpression(regexp))
  
  function parseRegularExpression(re) {
    let i = 0
    let input = re.source
    let groupIndex = 1
    
    // debugger
    let branches = parseBranches()
    return {
        type: "RegularExpression",
        start: 0,
        end: i,
        branches,
    }
    function parseBranches() {
      let branches = []
      while(input[i] !== ")" && i < input.length) {
        let branch = parseBranch()
        branches.push(branch)
        if (input[i] === "|") {
          i++ //skip the "|"
        }
      }
      
      return branches
    }
    
    function parseBranch() {
      let node = {
        type: "Branch",
        start: i,
        end: 0,
        row: "",
        character: []
      }

      while(input[i] !== "|" && input[i] !== ")" && i < input.length) {
        let char = parseOnePart()
        if (char.type === "Quantity") {
          if (node.character.length === 0) {
            throw new Error("syntax error !!!!!!!")
          } else {
            let repeatCharacter = node.character.pop()
            char.repeat = repeatCharacter
            char.start = repeatCharacter.start
            char.row = input.slice(char.start, char.end)
          }
        }
        node.character.push(char)
      }
      
      node.end = i
      node.row = input.slice(node.start, i)
      return node
    }
    
    function parseOnePart() {
      if (input[i] === "(") {
        return parseCaptureGroup()
      } else if (input[i] === "[") {
        return parseCharacterClass()
      } else if (input[i] === "{") {
        if (isQuantity() === true) {
          return parseQuantity()
        } else {
          return parseCharacter()
        }
      } else if (input[i] === "+" ||  input[i] === "*" || input[i] === "?") {
        return parseQuantity()
      } else if (input[i] === "\\") {
        return parseEscape()
      } else if (input[i] === "^" || input[i] === "$") {
        return parseCharacterSpecial()
      } else {
        return parseCharacter()
      }
    }
    
    function parseCharacterSpecial() {
      let node = {
        type: "Special",
        start: i,
        end: 0,
        row: ""
      }
      node.row = input[i]
      i++ // skip the character of special
      node.end = i
      return node
    }
    
    function isQuantity() {
      let start = i
      let commaTime = 0 //逗号出现的次数
      let isQuantity = true
      i++ // skip the "{"
      if (input[i] === "}") {
        isQuantity = false
      } else if (input[i] === ",") {
          isQuantity = false
      }
      
      while (input[i] !== "}" && i < input.length) {
        if (input[i] === ",") {
          commaTime++
          if (commaTime > 1) {
            isQuantity = false
            break
          }
        }
        if ((input[i] < "0" || input[i] > "9") && input[i] !== ",") {
          isQuantity = false
          break
        }
        i++
      }
      
      i = start
      return isQuantity
    }
    
    function parseEscape() {
      let node = {
        type: "Escape",
        start: i,
        end: 0,
        row: "",
        escape:"",
      }
      i++ // skip the "\"
      node.row = "\\" + input[i]
      node.escape = input[i]
      i++ // skip the character of escape
      node.end = i
      return node
    }
    function parseCaptureGroup() {
      let node = {
        type: "CaptureGroup",
        start: i,
        end: 0,
        row: "",
        capture: true,
        groupName: "",
        zeroWidthAssert: false,
        positive: true,
        lookahead: true,
        GroupIndex: groupIndex,
        branches: [],
      }
      
      i++ // skip the "("
      
      // (asdas)
      // (?<asdsa>asdas)
      // (?:asdas)
      
      // (?=asdas)
      // (?<asdas)
      // positive lookahead
      //positive lookbehind
      // negative lookbehind
      // negative lookahead
      
      if (input[i] === "?") {
        i++
        if (input[i] === ":") {
          node.capture = false
          i++
        } else if (input[i] === "=") {
          node.zeroWidthAssert = true
          node.capture = false
          i++
        } else if (input[i] === "!") {
          node.zeroWidthAssert = true
          node.positive = false
          i++
        } else if (input[i] === "<") {
          i++ //skip the "<"
          if (input[i] === "=") {
            node.zeroWidthAssert = true
            node.lookahead = false
            node.capture = false
            i++
          } else if (input[i] === "!") {
            node.zeroWidthAssert = true
            node.positive = false
            node.lookahead = false
            node.capture = false
            i++
          } else {
            node.groupName = parseGroupName()
          }
        }
      }
      if (node.zeroWidthAssert !== true && node.capture !== false) {
        groupIndex++
      } else {
        node.GroupIndex = undefined
      }
      while (input[i] !== ")" && i < input.length) {
        node.branches.push(...parseBranches())
      }
      i++ //skip the ")"

      function parseGroupName() {
        let start = i
        while (input[i] !== ">" && i < input.length) {
          i++
        }
        return input.slice(start, i++) // i++ is skip the ">"
      }
      
      node.end = i
      node.row = input.slice(node.start, i)
      return node
    }
    
    function parseQuantity() {
      let node = {
        type: "Quantity",
        start: i,
        end: 0,
        min: 0,
        max: Infinity,
        row: "",
        greed: true,
        repeat: null,
      }
      
      if (input[i] === "+") {
        node.min = 1
        i++
      } else if (input[i] === "*") {
        i++
      } else if (input[i] === "?") {
        node.max = 1
        i++
      } else if (input[i] === "{") {
        i++ // skip the "{"
        node.min = parseInt()
        node.max = node.min
        while (input[i] !== "}" && i < input.length) {
          if (input[i] === ",") {
            i++ //skip the ","
          } else {
            node.max = parseInt()

          }
        }
        
        i++ // skip "}"
      }
      
      if (input[i] === "?") { //非贪婪匹配
        node.greed = false
        i++
      }
      
      function parseInt() {
        let start = i
        while (input[i] >= "0" && input[i] <= "9") {
          i++
        }
        return Number(input.slice(start, i))
      }
      
      node.end = i
      node.row = input.slice(node.start, i)
      return node
    }
    
    function parseCharacter() {
      let node = {
        type: "Character",
        start: i,
        end: 0,
        row: ""
      }
      
      node.row = input[i]
      i++
      node.end = i
      
      return node
    }
    
    function parseCharacterClass() {
      let node = {
        type: "CharacterClass",
        start: i,
        end: 0,
        row: "",
        negative: false,
        Character: [],
      }
      i++ // this the "["
      if (input[i] === "^") {
        node.negative = true
        i++ //skip the "^"
      }
      
      while (input[i] !== "]" && i < input.length) {
        if (input[i] === "-" && input[i - 1] !== "[" && input[i - 1] !== "^" && input[i + 1] !== "]" && isGeneralCharGroup() === false) {
          let charSeries = parseCharSeries()
          let char = node.Character.pop()
          charSeries.character.unshift(char)
          charSeries.start = char.start
          charSeries.row = input.slice(charSeries.start, charSeries.end)
          node.Character.push(charSeries)
        } else if (input[i] === "\\") {
          node.Character.push(parseEscape())
        } else {
          node.Character.push(parseCharacter())
        }
      }
      i++ // skip the "]"
      
      /**
       * 判断 "-" 的前一个字符是不是范围字符组
       * @returns {boolean}
       */
      function isGeneralCharGroup() {
        let idx = node.Character.length - 1
        
        if (node.Character[idx].type !== "Escape") {
          return false
        }
        
        return Object.hasOwn(GENERAL_CHAR_GROUP, node.Character[idx].escape)
        
      }
      
      node.end = i
      node.row = input.slice(node.start, i)
      
      return node
    }
    
    /**
     * 把[]里的需要连续的字符放到用这个解析
     * @returns {{character: *[], start: number, end: number, row: string, type: string}}
     */
    function parseCharSeries() {
      let node = {
        type: "CharSeries",
        start: i,
        end: 0,
        row: "",
        character: [],
      }
      for (let k = 0; k < 2; k++) {
        if (input[i] === "-") {
          node.character.push(parseConnectChar())
        } else if (input[i] === "\\") {
          node.character.push(parseEscape())
        } else {
          node.character.push(parseCharacter())
        }
      }
      
      node.end = i
      node.row = input.slice(node.start, node.end)
      
      return node
    }
    
    function parseConnectChar() {
      let node =  {
        type: "connectChar",
        start: i,
        end: 0,
        row: "",
      }
      node.row = input[i]
      i++
      
      node.end = i
      node.row = input.slice(node.start, node.end)
      
      return node
    }
  }
  
  
  function drawRegularExpressionGraph(node) {
    let lineLength = elementPadding // 两端的线的长度
    let circleRadius = elementPadding // 两端的圆的半径
    let leftRightPadding = ((circleRadius << 1) + lineLength)
    let result = drawBranchesGraph(node.branches)
    let height = result.height + (elementPadding << 1)
    let YPosition = height / 2
    let g = elt("g").node
    let rect = elt("rect", {
      fill: "none",
      width: `${result.width + (leftRightPadding << 1)}`,
      height: `${height}`,
    }).node
    g.append(rect)
    result.node.setAttribute("transform", `translate(${leftRightPadding} ${elementPadding})`)
    g.append(result.node)
 
    g.append(drawCircle((circleRadius + 1), YPosition, circleRadius, "#28b463"))
    g.append(drawCircle((result.width + leftRightPadding + lineLength + circleRadius - 1), YPosition, circleRadius, "#cb4335"))
    
    let path = elt("path", {
      stroke: "black",
      "stroke-width": "2",
      d: `M ${circleRadius + circleRadius} ${YPosition}
      h ${lineLength} m ${result.width} 0 h ${lineLength}`
    }).node

    g.append(path)
  }
  
  /**
   *
   * @param cx string type, 圆的x坐标
   * @param cy string type, 圆的y坐标
   * @param r string type, 圆的半径
   * @param color string type, 圆的填充颜色
   * @returns {SVGAElement | SVGAnimateElement | SVGAnimateMotionElement | SVGAnimateTransformElement | SVGCircleElement | SVGClipPathElement | SVGDefsElement | SVGDescElement | SVGEllipseElement | SVGFEBlendElement | SVGFEColorMatrixElement | SVGFEComponentTransferElement | SVGFECompositeElement | SVGFEConvolveMatrixElement | SVGFEDiffuseLightingElement | SVGFEDisplacementMapElement | SVGFEDistantLightElement | SVGFEDropShadowElement | SVGFEFloodElement | SVGFEFuncAElement | SVGFEFuncBElement | SVGFEFuncGElement | SVGFEFuncRElement | SVGFEGaussianBlurElement | SVGFEImageElement | SVGFEMergeElement | SVGFEMergeNodeElement | SVGFEMorphologyElement | SVGFEOffsetElement | SVGFEPointLightElement | SVGFESpecularLightingElement | SVGFESpotLightElement | SVGFETileElement | SVGFETurbulenceElement | SVGFilterElement | SVGForeignObjectElement | SVGGElement | SVGImageElement | SVGLineElement | SVGLinearGradientElement | SVGMarkerElement | SVGMaskElement | SVGMetadataElement | SVGMPathElement | SVGPathElement | SVGPatternElement | SVGPolygonElement | SVGPolylineElement | SVGRadialGradientElement | SVGRectElement | SVGScriptElement | SVGSetElement | SVGStopElement | SVGStyleElement | SVGSVGElement | SVGSwitchElement | SVGSymbolElement | SVGTextElement | SVGTextPathElement | SVGTitleElement | SVGTSpanElement | SVGUseElement | SVGViewElement}
   */
  function drawCircle(cx, cy, r, color = "gray") {
    return elt("circle", {
      cx: `${cx}`,
      cy: `${cy}`,
      r: `${r}`,
      fill: color,
      stroke: "black",
      "stroke-width": "2",
    }).node
  }
  
  function elt(string, obj = {}, ...arg) {
    let node = document.createElementNS("http://www.w3.org/2000/svg", string)
    
    for (let key in obj) {
      node.setAttribute(key, obj[key])
    }
    for (let val of arg) {
      if (typeof val === "string") {
        let textNode = document.createTextNode(val)
        node.append(textNode)
      } else {
        node.append(val.node)
      }
    }
    railGraph.append(node)
    return {
      node: node,
      width: node.getBBox().width,
      height: node.getBBox().height,
      boxX: node.getBBox().x,
      boxY: node.getBBox().y,
    }
  }

  function drawBaselineOfGraph(graphObj, lineLength = elementPadding) {
    let g = elt("g", {
      class: "drawLine",
    }).node
    // let rect = elt("rect",{
    //   width: `${graphObj.width + lineLength * 2}`,
    //   height: `${graphObj.height}`,
    //   fill: "none",
    // }).node
    // g.append(rect)
    graphObj.node.setAttribute("transform", `translate(${lineLength} 0)`)
    g.append(graphObj.node)
    
    let path = elt("path", {
      stroke: "black",
      d: `M 0, ${graphObj.height / 2} h ${lineLength}
      m ${graphObj.width} 0 h${lineLength}`,
    }).node
    path.setAttribute("stroke-width", "2")
    g.append(path)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
    
  }
  
  /**
   * 根据text对象,计算其兄弟元素rect的宽度
   * @param textObj
   * @returns {*}
   */
  function calculateRectWidth(textObj) {
    let boxAspectRatio = textObj.height / textObj.width //text 的高宽比
    return textObj.width * boxAspectRatio + textObj.width //rect的宽度
  }
  
  function drawCharacterGraph(node, type = COMMON_CHAR) {
    let heightPadding = elementPadding * 2
    let widthPadding = elementPadding
    let textObj
    let g = elt("g").node

     if (type === ESCAPE_CHAR) {
       textObj = elt("text", {}, ESCAPE[node.row])
       
     } else if (type === SPECIAL_CHAR) {
       textObj = elt("text", {}, SPECIAL[node.row])
      
     } else { // type === COMMON_CHAR
      let leftQuote = elt("tspan", {
        fill: "#908c83",
        font: "12px Arial",
      }, '“')
      let rightQuote = elt("tspan", {
        fill: "#908c83",
        font: "12px Arial",
      }, '”')
      let character = elt("tspan", {
        font: "12px Arial",
      }, node.row)
      
      textObj = elt("text", {}, leftQuote, character, rightQuote)
    }
    
    let rectWidth = calculateRectWidth(textObj)
    
    let rectObj = elt("rect", {
      width: `${rectWidth}`,
      height: `${textObj.height + heightPadding}`,
      rx: "5",
      class: type,
    })
    
    let textDy = 0 - textObj.boxY + (heightPadding / 2) //text的dy, 是在其原来的位置上的偏移
    textObj.node.setAttribute("x", `${(rectWidth - textObj.width) / 2}`)
    textObj.node.setAttribute("dy", `${textDy}`)
    
    g.append(rectObj.node)
    g.append(textObj.node)

    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
    
  }
  
  function drawCharacterClassGraph(node) {
    let characterMap = {}
    let charObjArray = []
    let set = new Set()
    node.Character.forEach(it => {
      characterMap[it.row] = it
      set.add(it.row)
    })

    set.forEach(key => {
      charObjArray.push(matchFunc(characterMap[key]))
    })

    // let charObjArray = node.Character.map((it) => {
    //   return matchFunc(it)
    // })
    let g = elt("g").node
    let maxWidth = charObjArray.reduce((result, obj) => {
      if (result < obj.width) {
        return obj.width
      } else {
        return result
      }
    }, -Infinity)
    // console.log(charObjArray.length)
    let height = (charObjArray.length + 1) * elementPadding + (charObjArray.length * charObjArray[0].height)
    let rect = elt("rect", {
      width: `${maxWidth + elementPadding * 2}`,
      height: `${height}`,
      fill: "#cbcbba",
      rx: "5",
    }).node
    
    g.append(rect)
    let h = 0
    charObjArray.forEach(obj => {
      obj.node.setAttribute("transform", `translate(${(maxWidth - obj.width) / 2 + elementPadding} ${h + elementPadding})`)
      h += elementPadding + obj.height
      g.append(obj.node)
    })
    
   return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  /**
   * 画 中括号里的连续的字符
   * @param node
   * @returns {{node: SVGAElement | SVGAnimateElement | SVGAnimateMotionElement | SVGAnimateTransformElement | SVGCircleElement | SVGClipPathElement | SVGDefsElement | SVGDescElement | SVGEllipseElement | SVGFEBlendElement | SVGFEColorMatrixElement | SVGFEComponentTransferElement | SVGFECompositeElement | SVGFEConvolveMatrixElement | SVGFEDiffuseLightingElement | SVGFEDisplacementMapElement | SVGFEDistantLightElement | SVGFEDropShadowElement | SVGFEFloodElement | SVGFEFuncAElement | SVGFEFuncBElement | SVGFEFuncGElement | SVGFEFuncRElement | SVGFEGaussianBlurElement | SVGFEImageElement | SVGFEMergeElement | SVGFEMergeNodeElement | SVGFEMorphologyElement | SVGFEOffsetElement | SVGFEPointLightElement | SVGFESpecularLightingElement | SVGFESpotLightElement | SVGFETileElement | SVGFETurbulenceElement | SVGFilterElement | SVGForeignObjectElement | SVGGElement | SVGImageElement | SVGLineElement | SVGLinearGradientElement | SVGMarkerElement | SVGMaskElement | SVGMetadataElement | SVGMPathElement | SVGPathElement | SVGPatternElement | SVGPolygonElement | SVGPolylineElement | SVGRadialGradientElement | SVGRectElement | SVGScriptElement | SVGSetElement | SVGStopElement | SVGStyleElement | SVGSVGElement | SVGSwitchElement | SVGSymbolElement | SVGTextElement | SVGTextPathElement | SVGTitleElement | SVGTSpanElement | SVGUseElement | SVGViewElement, width: number, height: number}}
   */
  function drawCharSeriesGraph(node) {
    let objArray = node.character.map((charObj) => {
      if (charObj.type === "connectChar") { //画连接字符
        return drawConnectCharGraph(charObj)
      } else if (charObj.type === "Escape") { // 画转义符
        return drawEscapeGraph(charObj)
      } else {
        return drawCharacterGraph(charObj)
      }
    })
    let g = elt("g", {class: "charSeries"}).node
    let widthNum = objArray.reduce((result, obj) => {
      return result + obj.width
    }, 0)
    let needWidth = widthNum + ((objArray.length - 1) * elementPadding)
    let maxHeight = getMaxValueOfAllG(objArray, "height")
    let rect = elt("rect", {
      fill: "none",
      height: `${maxHeight}`,
      width: `${needWidth}`
    }).node
    g.append(rect)
    let x = 0
    objArray.forEach((obj) => {
      obj.node.setAttribute("transform", `translate(${x} ${(maxHeight - obj.height) >>> 1})`)
      x += obj.width + elementPadding
      g.append(obj.node)
    })
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  function drawConnectCharGraph(node) {
    let g = elt("g", {class: "connectChar"}).node
    let text = elt("text", {}, node.row)
    let dy = 0 - text.boxY
    text.node.setAttribute("dy", `${dy}`)
    g.append(text.node)
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }

  function drawQuantityGraph(node) {
    let padding = elementPadding * 2 // 这里不要动,如果动的话,就要改 path 的 d 的值
    let g = elt("g").node
    let character = matchFunc(node.repeat)
    character.node.setAttribute("transform", `translate(${padding} ${padding})`)
    let rect = elt("rect", {
      width: `${character.width + (padding * 2)}`,
      height: `${character.height + (padding * 2)}`,
      fill: "none",
    }).node
    g.append(rect)
    g.append(character.node)
    
    let strokeWidth = "2"
    let yPosition = character.height / 2 + (padding) // 计算与其他元素连线时,连接线在纵轴的位置
    let straightLine = `M 0 ${yPosition} h ${padding} m ${character.width} 0 h ${padding}`
    let zeroTime = "" // 最小为0次的匹配
    let repeatedly = "" //最大的匹配大于1次
    if (node.min === 0) {
      zeroTime = `M 0 ${yPosition}
        a ${radiiEllipse} ${radiiEllipse} 0 0 0 ${elementPadding},${-elementPadding}
        L ${elementPadding} ${padding >>> 1}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${elementPadding},${-elementPadding}
        h ${character.width}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${elementPadding},${elementPadding}
        L ${character.width + padding + (elementPadding)} ${yPosition - (elementPadding)}
        a ${radiiEllipse} ${radiiEllipse} 0 0 0 ${elementPadding},${elementPadding}`
    }
    if (node.max > 1) {
      repeatedly = `M ${padding + character.width} ${yPosition}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${elementPadding},${elementPadding}
        L ${character.width + padding + (elementPadding)} ${character.height + padding + (padding >>> 1)}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${-elementPadding},${elementPadding}
        h ${-character.width}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${-elementPadding},${-elementPadding}
        L ${elementPadding} ${yPosition + (elementPadding)}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${elementPadding},${-elementPadding}`
    }
    
    let path = elt("path", {
      fill: "none",
      stroke: "black",
      "stroke-width": strokeWidth,
      d: straightLine + zeroTime + repeatedly
    }).node
    
    g.append(path)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  function drawBranchGraph(node) {
    let g = elt("g").node
    let mergeCharArray = []
    node.character.forEach(obj => {
    let tempObj = null
      if (obj.type === "Character") {
        if ((tempObj = mergeCharArray[mergeCharArray.length - 1])?.type === "Character") {
          tempObj.row += obj.row
        } else {
          mergeCharArray.push(obj)
        }
      } else {
        mergeCharArray.push(obj)
      }
    })
    let objArray = mergeCharArray.map(obj => {
      return matchFunc(obj)
    })
    objArray = objArray.map(obj => {
      return drawBaselineOfGraph(obj)
    })
    let width = objArray.reduce((result, obj) => {
      return result + obj.width
    }, 0)
    let height = getMaxValueOfAllG(objArray, "height")
    let rect = elt("rect", {
      fill: "none",
      width: `${width}`,
      // height: `${height + elementPadding * 2}`,
      height: `${height}`,
      rx: "5"
    }).node
    g.append(rect)
    
    let x = 0
    let rectHeight = rect.getBBox().height
    objArray.forEach(obj => {
      obj.node.setAttribute("transform", `translate(${x} ${(rectHeight - obj.height) / 2})`)
      x += obj.width
      g.append(obj.node)
    })
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  /**
   * 计算对象数组里的最大宽度或高度
   * @param objArray 已经画好的对象组成的数组
   * @param key width or height
   * @returns value 所有对象里宽度的最大值或者高度的最大值
   */
  function getMaxValueOfAllG(objArray, key) {
    return objArray.reduce((result, obj) => {
      if (result < obj[key]) {
        return obj[key]
      } else {
        return result
      }
    }, -Infinity)
  }
  
  function matchFunc(node) {
    if (node.type === COMMON_CHAR) {
      return drawCharacterGraph(node)
    } else if (node.type === "CharacterClass") {
      return drawCharacterClassGraph(node)
    } else if (node.type === "CaptureGroup") {
      return drawCaptureGraph(node)
    } else if (node.type === "Quantity") {
      return drawQuantityGraph(node)
    } else if (node.type === "Branch") {
      return drawBranchGraph(node)
    } else if (node.type === "CharSeries") {
      return drawCharSeriesGraph(node)
    } else if (node.type === ESCAPE_CHAR) {
      return drawEscapeGraph(node)
    } else if (node.type === SPECIAL_CHAR) {
      return drawSpecialCharGraph(node)
    }
    return undefined
  }
  
  function drawSpecialCharGraph(node) {
    if (Object.hasOwn(SPECIAL, node.row)) {
      return drawCharacterGraph(node, SPECIAL_CHAR)
    } else {
      return drawCharacterGraph(node, COMMON_CHAR)
    }
  }
  
  function drawBranchesGraph(nodes) {
    let padding = elementPadding * 4
    let g = elt("g").node
    let branchArray = nodes.map(obj => {
      return matchFunc(obj)
    })
    if (branchArray.length === 1) { //如果只有一个分支,则直接把画好的那个对象返回
      return branchArray[0]
    }
    let heightMun = branchArray.reduce((result, obj) => {
      return result + obj.height
    }, 0)
    let maxWidth = getMaxValueOfAllG(branchArray, "width")
    let rectHeight = (branchArray.length - 1) * elementPadding + heightMun
    let rect = elt("rect", {
      fill: "none",
      width: `${maxWidth + padding * 2}`,
      height: `${rectHeight}`,
      rx: "5",
    }).node
    g.append(rect)
    let newBranchArray = branchArray.map(obj => {
      return alignLineOfWidth(obj, maxWidth)
    })
    let yGather = rectHeight / 2 //分支连线的Y轴的聚集点
    let yPositionGraph = [] //记录每个graph的联线位置 Y轴的位置
    let y = 0
    newBranchArray.forEach(obj => {
      obj.node.setAttribute("transform", `translate(${padding} ${y})`)
      yPositionGraph.push(obj.height / 2 + y)
      // console.log(obj.height / 2 + y)
      y += obj.height + elementPadding
      g.append(obj.node)
    })
    
    let drawLine = ""
    yPositionGraph.forEach(yPosition => {
      let contPointX = 0 // 贝塞尔曲线的控制点的 X 坐标
      if (Math.abs(yGather - yPosition) < padding) {
        contPointX = padding / 2
      } else {
        contPointX = padding
      }
      drawLine += `
          M 0 ${yGather}
          C ${contPointX},${yGather} ${padding - contPointX},${yPosition} ${padding},${yPosition}

          M ${padding + maxWidth} ${yPosition}
          C ${maxWidth + padding + contPointX},${yPosition} ${maxWidth + padding + (padding - contPointX)},${yGather}
          ${maxWidth + (padding * 2)},${yGather}
          `
    })
    
    let path = elt("path", {
      fill: "none",
      stroke: "black",
      "stroke-width": "2",
      d: drawLine,
    }).node
    g.append(path)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  /**
   * 把obj小于targetWidth的部分,用线补齐
   * @param obj 需要补齐宽度的对象
   * @param targetWidth obj需要达到的宽度
   * @returns {*|{node: 宽度补齐后的对象, width: 对象的宽度, height: 对象的高度}}
   */
  function alignLineOfWidth(obj, targetWidth) {
    if (obj.width === targetWidth) {
      return obj
    }
    let lineLength = (targetWidth - obj.width) / 2
    return drawBaselineOfGraph(obj, lineLength)
  }
  
  function drawCaptureGraph(node) {
    let strokeWidth = 2
    // let leftRightPadding = strokeWidth >>> 1
    let branches = drawBranchesGraph(node.branches)
    let g = elt("g").node
    let rect = elt("rect", {
      width: `${branches.width}`,
      height: `${branches.height + (elementPadding * 2)}`,
      rx: "5",
      "stroke-dasharray": "5,5",
      stroke: "gray",
      "stroke-width": `${strokeWidth}`,
      fill: "none",
      class: "capture"
    }).node
    branches.node.setAttribute("transform", `translate(0 ${elementPadding})`)
    g.append(branches.node)
    g.append(rect)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  function drawEscapeGraph(node) {
    let char = node.escape
    if (Object.hasOwn(ESCAPE, char)) { // 说明是普通字符的转义字符
      
      return drawCharacterGraph({row: char}, ESCAPE_CHAR)
      
    } else { // 说明是特殊字符的转义字符,这时要当做普通字符处理
      return drawCharacterGraph({row: char}, COMMON_CHAR)
    }
  
  }
  
</script>
</body>
</html>


































