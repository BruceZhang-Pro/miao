<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>regexp rail graph</title>
</head>
<body>
<!--<svg viewBox="0 0 500 500" id="rail-graph" xmlns="http://www.w3.org/2000/svg">-->
<svg width="1500px" height="800px" id="rail-graph" xmlns="http://www.w3.org/2000/svg">

</svg>
<script>
  "use strict"
  
  let elementPadding = 10
  let radiiEllipse = elementPadding // 画椭圆时的 x 和 y 的半径, 这里设置为一样的 1倍的padding为正常的椭圆曲线 3倍的padding为机甲风曲线
  let railGraph = document.querySelector("#rail-graph") // svg 对象
  
  //待改
  // /asd{,3}/  // 把{,3} 全当做普通字符
  // /asd{,}/  // 把{,} 全当做普通字符
  // [abz049_-]  //把 - 在开头和结尾时,当做普通字符  其余的时候当做 前后字母的过度字符
  // 转移字符看看有没有问题
  
  // /foo|qwe(as[^2564]|rt{2,})+/
  // /(?<abc>af)foo|(bar|(ba+z{2,})[aeiou])/
  
  // let regexp = /a[yas]+/
  // drawBranchGraph(parseRegularExpression(regexp).branches[0])
  
  // let regexp = /[cb]|a/
  // let regexp = /as*d|(s[wv])+|rt/
  // drawBranchesGraph(parseRegularExpression(regexp).branches)
  // let regexp = /(s)/
  // drawCaptureGraph(parseRegularExpression(regexp).branches[0].character[0])
  
  // let regexp = /as*d|(s[wv])+|rt/
  // let regexp = /\[[-+]?([048]|\d*(?:[02468][048]|[13579][26]))\]/ //  这个没法画出来,需要改
  // console.log(parseRegularExpression(regexp))
  // let regexp = /a[y(ak)s]+/
  
  // let regexp = /(foo+|aaaa)*b(a[abz049_-]){2,}?(baz|baa)+|baaa/  // 大喵的
  // drawRegularExpressionGraph(parseRegularExpression(regexp))
  
  function parseRegularExpression(re) {
    let i = 0
    let input = re.source
    let groupIndex = 1
    
    // debugger
    let branches = parseBranches()
    return {
        type: "RegularExpression",
        start: 0,
        end: i,
        branches,
    }
    function parseBranches() {
      let branches = []
      while(input[i] !== ")" && i < input.length) {
        let branch = parseBranch()
        branches.push(branch)
        if (input[i] === "|") {
          i++ //skip the "|"
        }
      }
      
      return branches
    }
    
    function parseBranch() {
      let node = {
        type: "Branch",
        start: i,
        end: 0,
        row: "",
        character: []
      }

      while(input[i] !== "|" && input[i] !== ")" && i < input.length) {
        let char = parseOnePart()
        if (char.type === "Quantity") {
          if (node.character.length === 0) {
            throw new Error("syntax error !!!!!!!")
          } else {
            let repeatCharacter = node.character.pop()
            char.repeat = repeatCharacter
            char.start = repeatCharacter.start
            char.row = input.slice(char.start, char.end)
          }
        }
        node.character.push(char)
      }
      
      node.end = i
      node.row = input.slice(node.start, i)
      return node
    }
    
    function parseOnePart() {
      if (input[i] === "(") {
        return parseCaptureGroup()
      } else if (input[i] === "[") {
        return parseCharacterClass()
      } else if (input[i] === "{" || input[i] === "+" ||  input[i] === "*" || input[i] === "?") {
        return parseQuantity()
      } else if (input[i] === "\\") {
        return parseEscape()
      } else {
        return parseCharacter()
      }
    }
    function parseEscape() {
      let node = {
        type: "Escape",
        start: i,
        end: 0,
        row: "",
        escape:"",
      }
      i++
      node.row = "\\" + input[i]
      node.escape = input[i]
      i++
      node.end = i
      return node
    }
    function parseCaptureGroup() {
      let node = {
        type: "CaptureGroup",
        start: i,
        end: 0,
        row: "",
        capture: true,
        groupName: "",
        zeroWidthAssert: false,
        positive: true,
        lookahead: true,
        GroupIndex: groupIndex,
        branches: [],
      }
      
      i++ // skip the "("
      
      // (asdas)
      // (?<asdsa>asdas)
      // (?:asdas)
      
      // (?=asdas)
      // (?<asdas)
      // positive lookahead
      //positive lookbehind
      // negative lookbehind
      // negative lookahead
      
      if (input[i] === "?") {
        i++
        if (input[i] === ":") {
          node.capture = false
          i++
        } else if (input[i] === "=") {
          node.zeroWidthAssert = true
          node.capture = false
          i++
        } else if (input[i] === "!") {
          node.zeroWidthAssert = true
          node.positive = false
          i++
        } else if (input[i] === "<") {
          i++ //skip the "<"
          if (input[i] === "=") {
            node.zeroWidthAssert = true
            node.lookahead = false
            node.capture = false
            i++
          } else if (input[i] === "!") {
            node.zeroWidthAssert = true
            node.positive = false
            node.lookahead = false
            node.capture = false
            i++
          } else {
            node.groupName = parseGroupName()
          }
        }
      }
      if (node.zeroWidthAssert !== true && node.capture !== false) {
        groupIndex++
      } else {
        node.GroupIndex = undefined
      }
      while (input[i] !== ")" && i < input.length) {
        node.branches.push(...parseBranches())
      }
      i++ //skip the ")"

      function parseGroupName() {
        let start = i
        while (input[i] !== ">" && i < input.length) {
          i++
        }
        return input.slice(start, i++) // i++ is skip the ">"
      }
      
      node.end = i
      node.row = input.slice(node.start, i)
      return node
    }
    
    function parseQuantity() {
      let node = {
        type: "Quantity",
        start: i,
        end: 0,
        min: 0,
        max: Infinity,
        row: "",
        greed: true,
        repeat: null,
      }
      
      if (input[i] === "+") {
        node.min = 1
        i++
      } else if (input[i] === "*") {
        i++
      } else if (input[i] === "?") {
        node.max = 1
        i++
      } else if (input[i] === "{") {
        i++
        node.min = parseInt()
        i++ //skip the ","
        if (input[i] === "}") { //说明为 {x,} 这种形式
          i++ // skip "}"
        } else {
          node.max = parseInt()
          i++ // skip the "}"
        }
      }
      
      if (input[i] === "?") { //非贪婪匹配
        node.greed = false
        i++
      }
      
      function parseInt() {
        let start = i
        while (input[i] >= "0" && input[i] <= "9") {
          i++
        }
        return Number(input.slice(start, i))
      }
      
      node.end = i
      node.row = input.slice(node.start, i)
      return node
    }
    
    function parseCharacter() {
      let node = {
        type: "Character",
        start: i,
        end: 0,
        row: ""
      }
      
      node.row = input[i]
      i++
      node.end = i
      
      return node
    }
    
    function parseCharacterClass() {
      let node = {
        type: "CharacterClass",
        start: i,
        end: 0,
        row: "",
        negative: false,
        Character: [],
      }
      i++ // this the "["
      if (input[i] === "^") {
        node.negative = true
        i++ //skip the "^"
      }
      
      while (input[i] !== "]" && i < input.length) {
        if (input[i] === "-" && input[i - 1] !== "[" && input[i - 1] !== "^" && input[i + 1] !== "]") {
          let charSeries = parseCharSeries()
          let char = node.Character.pop()
          charSeries.character.unshift(char)
          charSeries.start = char.start
          charSeries.row = input.slice(charSeries.start, charSeries.end)
          node.Character.push(charSeries)
        } else {
          node.Character.push(parseCharacter())
        }
      }
      i++ // skip the "]"
      
      node.end = i
      node.row = input.slice(node.start, i)
      
      return node
    }
    
    /**
     * 把[]里的需要连续的字符放到用这个解析
     * @param time  "-" 之前的字符已经解析过了,所以默认值为2
     * @returns {{character: *[], start: number, end: number, row: string, type: string}}
     */
    function parseCharSeries(time = 2) {
      let node = {
        type: "CharSeries",
        start: i,
        end: 0,
        row: "",
        character: [],
      }
      for (let k = 0; k < time; k++) {
        if (input[i] === "-") {
          node.character.push(parseContentChar())
        } else {
          node.character.push(parseCharacter())
        }
      }
      
      node.end = i
      node.row = input.slice(node.start, node.end)
      
      return node
    }
    
    function parseContentChar() {
      let node =  {
        type: "contentChar",
        start: i,
        end: 0,
        row: "",
      }
      node.row = input[i]
      i++
      
      node.end = i
      node.row = input.slice(node.start, node.end)
      
      return node
    }
  }
  
  
  function drawRegularExpressionGraph(node) {
    let lineLength = elementPadding // 两端的线的长度
    let circleRadius = elementPadding // 两端的圆的半径
    let leftRightPadding = ((circleRadius << 1) + lineLength)
    let result = drawBranchesGraph(node.branches)
    let height = result.height + (elementPadding << 1)
    let YPosition = height / 2
    let g = elt("g").node
    let rect = elt("rect", {
      fill: "#a4c04a",
      width: `${result.width + (leftRightPadding << 1)}`,
      height: `${height}`,
    }).node
    g.append(rect)
    result.node.setAttribute("transform", `translate(${leftRightPadding} ${elementPadding})`)
    g.append(result.node)
 
    g.append(drawCircle((circleRadius + 1), YPosition, circleRadius, "#28b463"))
    g.append(drawCircle((result.width + leftRightPadding + lineLength + circleRadius - 1), YPosition, circleRadius, "#cb4335"))
    
    let path = elt("path", {
      stroke: "black",
      "stroke-width": "2",
      d: `M ${circleRadius + circleRadius} ${YPosition}
      h ${lineLength} m ${result.width} 0 h ${lineLength}`
    }).node

    g.append(path)
  }
  
  /**
   *
   * @param cx string type, 圆的x坐标
   * @param cy string type, 圆的y坐标
   * @param r string type, 圆的半径
   * @param color string type, 圆的填充颜色
   * @returns {SVGAElement | SVGAnimateElement | SVGAnimateMotionElement | SVGAnimateTransformElement | SVGCircleElement | SVGClipPathElement | SVGDefsElement | SVGDescElement | SVGEllipseElement | SVGFEBlendElement | SVGFEColorMatrixElement | SVGFEComponentTransferElement | SVGFECompositeElement | SVGFEConvolveMatrixElement | SVGFEDiffuseLightingElement | SVGFEDisplacementMapElement | SVGFEDistantLightElement | SVGFEDropShadowElement | SVGFEFloodElement | SVGFEFuncAElement | SVGFEFuncBElement | SVGFEFuncGElement | SVGFEFuncRElement | SVGFEGaussianBlurElement | SVGFEImageElement | SVGFEMergeElement | SVGFEMergeNodeElement | SVGFEMorphologyElement | SVGFEOffsetElement | SVGFEPointLightElement | SVGFESpecularLightingElement | SVGFESpotLightElement | SVGFETileElement | SVGFETurbulenceElement | SVGFilterElement | SVGForeignObjectElement | SVGGElement | SVGImageElement | SVGLineElement | SVGLinearGradientElement | SVGMarkerElement | SVGMaskElement | SVGMetadataElement | SVGMPathElement | SVGPathElement | SVGPatternElement | SVGPolygonElement | SVGPolylineElement | SVGRadialGradientElement | SVGRectElement | SVGScriptElement | SVGSetElement | SVGStopElement | SVGStyleElement | SVGSVGElement | SVGSwitchElement | SVGSymbolElement | SVGTextElement | SVGTextPathElement | SVGTitleElement | SVGTSpanElement | SVGUseElement | SVGViewElement}
   */
  function drawCircle(cx, cy, r, color = "gray") {
    return elt("circle", {
      cx: `${cx}`,
      cy: `${cy}`,
      r: `${r}`,
      fill: color,
      stroke: "black",
      "stroke-width": "2",
    }).node
  }
  
  function elt(string, obj = {}, ...arg) {
    let node = document.createElementNS("http://www.w3.org/2000/svg", string)
    
    for (let key in obj) {
      node.setAttribute(key, obj[key])
    }
    for (let val of arg) {
      if (typeof val === "string") {
        let textNode = document.createTextNode(val)
        node.append(textNode)
      } else {
        node.append(val.node)
      }
    }
    railGraph.append(node)
    return {
      node: node,
      width: node.getBBox().width,
      height: node.getBBox().height,
      boxX: node.getBBox().x,
      boxY: node.getBBox().y,
    }
  }

  function drawBaselineOfGraph(graphObj, lineLength = elementPadding) {
    let g = elt("g", {
      class: "drawLine",
    }).node
    // let rect = elt("rect",{
    //   width: `${graphObj.width + lineLength * 2}`,
    //   height: `${graphObj.height}`,
    //   fill: "#a4c04a",
    // }).node
    // g.append(rect)
    graphObj.node.setAttribute("transform", `translate(${lineLength} 0)`)
    g.append(graphObj.node)
    
    let path = elt("path", {
      stroke: "black",
      d: `M 0, ${graphObj.height / 2} h ${lineLength}
      m ${graphObj.width} 0 h${lineLength}`,
    }).node
    path.setAttribute("stroke-width", "2")
    g.append(path)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
    
  }
  
  function drawCharacterGraph(node) {
    let heightPadding = elementPadding * 2
    let widthPadding = elementPadding
    
    let g = elt("g").node
    let leftQuote = elt("tspan", {
      fill: "#908c83",
      font: "12px Arial",
    }, '“')
    let rightQuote = elt("tspan", {
      fill: "#908c83",
      font: "12px Arial",
    }, '”')
    let character = elt("tspan", {
      font: "12px Arial",
    }, node.row)

    let textObj = elt("text", {}, leftQuote, character, rightQuote)
    let boxAspectRatio = textObj.height / textObj.width //text 的高宽比
    let rectWidth = textObj.width * boxAspectRatio + textObj.width //rect的宽度
    
    let rectObj = elt("rect", {
      width: `${rectWidth}`,
      height: `${textObj.height + heightPadding}`,
      fill: "#dae8e5",
      rx: "5",
    })
    
    let textDy = 0 - textObj.boxY + (heightPadding / 2) //text的dy, 是在其原来的位置上的偏移
    textObj.node.setAttribute("x", `${(rectWidth - textObj.width) / 2}`)
    textObj.node.setAttribute("dy", `${textDy}`)
    
    // gObj.node.setAttribute("transform", `translate(100 100)`)
    g.append(rectObj.node)
    g.append(textObj.node)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
    
  }
  
  function drawCharacterClassGraph(node) {
    let charObjArray = node.Character.map((it) => {
      return drawCharacterGraph(it)
    })
    let g = elt("g").node
    let maxWidth = charObjArray.reduce((result, obj) => {
      if (result < obj.width) {
        return obj.width
      } else {
        return result
      }
    }, -Infinity)
    // console.log(charObjArray.length)
    let height = (charObjArray.length + 1) * elementPadding + (charObjArray.length * charObjArray[0].height)
    let rect = elt("rect", {
      width: `${maxWidth + elementPadding * 2}`,
      height: `${height}`,
      fill: "#cbcbba",
      rx: "5",
    }).node
    
    g.append(rect)
    let h = 0
    charObjArray.forEach(obj => {
      obj.node.setAttribute("transform", `translate(${(maxWidth - obj.width) / 2 + elementPadding} ${h + elementPadding})`)
      h += elementPadding + obj.height
      g.append(obj.node)
    })
    
   return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }

  function drawQuantityGraph(node) {
    let padding = elementPadding * 2 // 这里不要动,如果动的话,就要改 path 的 d 的值
    let g = elt("g").node
    let character = matchFunc(node.repeat)
    character.node.setAttribute("transform", `translate(${padding} ${padding})`)
    let rect = elt("rect", {
      width: `${character.width + (padding * 2)}`,
      height: `${character.height + (padding * 2)}`,
      fill: "#a4c04a",
    }).node
    g.append(rect)
    g.append(character.node)
    
    let strokeWidth = "2"
    let yPosition = character.height / 2 + (padding) // 计算与其他元素连线时,连接线在纵轴的位置
    let straightLine = `M 0 ${yPosition} h ${padding} m ${character.width} 0 h ${padding}`
    let zeroTime = "" // 最小为0次的匹配
    let repeatedly = "" //最大的匹配大于1次
    if (node.min === 0) {
      zeroTime = `M 0 ${yPosition}
        a ${radiiEllipse} ${radiiEllipse} 0 0 0 ${elementPadding},${-elementPadding}
        L ${elementPadding} ${padding >>> 1}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${elementPadding},${-elementPadding}
        h ${character.width}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${elementPadding},${elementPadding}
        L ${character.width + padding + (elementPadding)} ${yPosition - (elementPadding)}
        a ${radiiEllipse} ${radiiEllipse} 0 0 0 ${elementPadding},${elementPadding}`
    }
    if (node.max > 1) {
      repeatedly = `M ${padding + character.width} ${yPosition}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${elementPadding},${elementPadding}
        L ${character.width + padding + (elementPadding)} ${character.height + padding + (padding >>> 1)}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${-elementPadding},${elementPadding}
        h ${-character.width}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${-elementPadding},${-elementPadding}
        L ${elementPadding} ${yPosition + (elementPadding)}
        a ${radiiEllipse} ${radiiEllipse} 0 0 1 ${elementPadding},${-elementPadding}`
    }
    
    let path = elt("path", {
      fill: "none",
      stroke: "black",
      "stroke-width": strokeWidth,
      d: straightLine + zeroTime + repeatedly
    }).node
    
    g.append(path)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  function drawBranchGraph(node) {
    let g = elt("g").node
    let objArray = node.character.map(obj => {
      return matchFunc(obj)
    })
    objArray = objArray.map(obj => {
      return drawBaselineOfGraph(obj)
    })
    let width = objArray.reduce((result, obj) => {
      return result + obj.width
    }, 0)
    let height = getMaxValueOfAllG(objArray, "height")
    let rect = elt("rect", {
      fill: "#a4c04a",
      width: `${width}`,
      // height: `${height + elementPadding * 2}`,
      height: `${height}`,
      rx: "5"
    }).node
    g.append(rect)
    
    let x = 0
    let rectHeight = rect.getBBox().height
    objArray.forEach(obj => {
      obj.node.setAttribute("transform", `translate(${x} ${(rectHeight - obj.height) / 2})`)
      x += obj.width
      g.append(obj.node)
    })
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  /**
   * 计算对象数组里的最大宽度或高度
   * @param objArray 已经画好的对象组成的数组
   * @param key width or height
   * @returns value 所有对象里宽度的最大值或者高度的最大值
   */
  function getMaxValueOfAllG(objArray, key) {
    return objArray.reduce((result, obj) => {
      if (result < obj[key]) {
        return obj[key]
      } else {
        return result
      }
    }, -Infinity)
  }
  
  function matchFunc(node) {
    if (node.type === "Character") {
      return drawCharacterGraph(node)
    } else if (node.type === "CharacterClass") {
      return drawCharacterClassGraph(node)
    } else if (node.type === "CaptureGroup") {
      return drawCaptureGraph(node)
    } else if (node.type === "Quantity") {
      return drawQuantityGraph(node)
    } else if (node.type === "Branch") {
      return drawBranchGraph(node)
    }
    return undefined
  }
  
  function drawBranchesGraph(nodes) {
    let padding = elementPadding * 4
    let g = elt("g").node
    let branchArray = nodes.map(obj => {
      return matchFunc(obj)
    })
    if (branchArray.length === 1) { //如果只有一个分支,则直接把画好的那个对象返回
      return branchArray[0]
    }
    let heightMun = branchArray.reduce((result, obj) => {
      return result + obj.height
    }, 0)
    let maxWidth = getMaxValueOfAllG(branchArray, "width")
    let rectHeight = (branchArray.length - 1) * elementPadding + heightMun
    let rect = elt("rect", {
      fill: "#a4c04a",
      width: `${maxWidth + padding * 2}`,
      height: `${rectHeight}`,
      rx: "5",
    }).node
    g.append(rect)
    let newBranchArray = branchArray.map(obj => {
      return alignLineOfWidth(obj, maxWidth)
    })
    let yGather = rectHeight / 2 //分支连线的Y轴的聚集点
    let yPositionGraph = [] //记录每个graph的联线位置 Y轴的位置
    let y = 0
    newBranchArray.forEach(obj => {
      obj.node.setAttribute("transform", `translate(${padding} ${y})`)
      yPositionGraph.push(obj.height / 2 + y)
      // console.log(obj.height / 2 + y)
      y += obj.height + elementPadding
      g.append(obj.node)
    })
    
    let drawLine = ""
    yPositionGraph.forEach(yPosition => {
      let contPointX = 0 // 贝塞尔曲线的控制点的 X 坐标
      if (Math.abs(yGather - yPosition) < padding) {
        contPointX = padding / 2
      } else {
        contPointX = padding
      }
      drawLine += `
          M 0 ${yGather}
          C ${contPointX},${yGather} ${padding - contPointX},${yPosition} ${padding},${yPosition}

          M ${padding + maxWidth} ${yPosition}
          C ${maxWidth + padding + contPointX},${yPosition} ${maxWidth + padding + (padding - contPointX)},${yGather}
          ${maxWidth + (padding * 2)},${yGather}
          `
    })
    
    let path = elt("path", {
      fill: "none",
      stroke: "black",
      "stroke-width": "2",
      d: drawLine,
    }).node
    g.append(path)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  /**
   * 把obj小于targetWidth的部分,用线补齐
   * @param obj 需要补齐宽度的对象
   * @param targetWidth obj需要达到的宽度
   * @returns {*|{node: 宽度补齐后的对象, width: 对象的宽度, height: 对象的高度}}
   */
  function alignLineOfWidth(obj, targetWidth) {
    if (obj.width === targetWidth) {
      return obj
    }
    let lineLength = (targetWidth - obj.width) / 2
    return drawBaselineOfGraph(obj, lineLength)
  }
  
  function drawCaptureGraph(node) {
    let strokeWidth = 2
    // let leftRightPadding = strokeWidth >>> 1
    let branches = drawBranchesGraph(node.branches)
    let g = elt("g").node
    let rect = elt("rect", {
      width: `${branches.width}`,
      height: `${branches.height + (elementPadding * 2)}`,
      rx: "5",
      "stroke-dasharray": "5,5",
      stroke: "gray",
      "stroke-width": `${strokeWidth}`,
      fill: "none",
      class: "capture"
    }).node
    branches.node.setAttribute("transform", `translate(0 ${elementPadding})`)
    g.append(branches.node)
    g.append(rect)
    
    return {
      node: g,
      width: g.getBBox().width,
      height: g.getBBox().height,
    }
  }
  
  function drawEscapeGraph(node) {
  
  }
  
</script>
</body>
</html>


































